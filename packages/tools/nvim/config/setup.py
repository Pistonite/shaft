# std data path is: vim.fn.stdpath("data")
#  - Linux: ~/.local/share/nvim
#  - Windows: %LOCALAPPDATA%\nvim-data (~\AppData\Local\nvim-data)
# std config path is: vim.fn.stdpath("config")
#  - Linux: ~/.config/nvim
#  - Windows: %LOCALAPPDATA%\nvim (~\AppData\Local\nvim)

# data paths:
# STD_DATA/
# - lazy/lazy.nvim        # Lazy.nvim package manager
# - mason/                # Mason LSP package manager
# - piston/               # Data referenced by this (my) config
#   - aicoder/            # AI Coding Diffs
#   - undodir/            # VIM Undo Dir
#   - .yank               # Temporary Host Yank File
#
# config paths:
# STD_CONFIG/
# - setup.py              # This file
# - init.lua              # Config Entry Point
# .. (TODO)
#
"""
Usage: setup.py [command]

Commands:
  nuke            Nuke existing configurations and everything you installed
  clean           Clean temporary files generated by Nvim
  apply           Apply updated configurations
  merge PART      Merge configurations of PART
    PART: [claudecode]
  repack          Pack local configurations for update
"""

import json
import os
import shutil
import subprocess
import sys
import time

def main():
    commands = {
        "nuke": nuke,
        "clean": clean,
        "apply": apply,
        "merge": merge,
        "repack": repack,
    }

    if len(sys.argv) < 2:
        usage()
        sys.exit(1)

    command = sys.argv[1]

    if command in ("-h", "--help"):
        usage()
        sys.exit(0)

    if command not in commands:
        print(f"Unknown command: {command}")
        usage()
        sys.exit(1)

    commands[command]()

# === COMMANDS =================================================================

NUKE_DRY_RUN = False

def nuke():
    """Nuke existing configurations."""

    clean()

    info = read_info()
    data_path = get_std_data_path()
    config_path = get_std_config_path()

    specs = [
        "data:mason",
        "config:piston/cache",
        "config:claudecode.nvim",
        # legacy: might be there in older config gens
        "data:site/pack",
        "config:cache",
        "config:after",
        "config:external",
        "config:plugin",
        "config:lua/claudecode",
    ]
    for rel_path in info["shaft"]["data-paths"]:
        specs.append(f"data:{rel_path}")
    specs.append(f"data:{info['lazy']['data-path']}")
    specs.append(f"config:{info['claude']['config-path']}")
    specs.append(f"data:{info['claude']['data-path']}")

    for spec in specs:
        nuke_spec(spec, data_path, config_path, NUKE_DRY_RUN)

    vim_path = os.path.expanduser("~/.vim")
    if os.path.exists(vim_path):
        if NUKE_DRY_RUN:
            print(f"would delete: {vim_path}")
        else:
            rmdir(vim_path)
            print(f"nuked: {vim_path}")

def clean():
    """Clean temporary files"""
    info = read_info()
    data_path = get_std_data_path()
    config_path = get_std_config_path()
    specs = []
    for rel_path in info["shaft"]["clean"]["data"]:
        specs.append(f"data:{rel_path}")
    for rel_path in info["shaft"]["clean"]["config"]:
        specs.append(f"config:{rel_path}")
    for spec in specs:
        nuke_spec(spec, data_path, config_path, NUKE_DRY_RUN)
    undo_dir = os.path.join(data_path, info["shaft"]["clean"]["undodata"])
    if os.path.isdir(undo_dir):
        now = time.time()
        max_age_seconds = 30 * 24 * 60 * 60  # 30 days
        for entry in os.listdir(undo_dir):
            file_path = os.path.join(undo_dir, entry)
            if os.path.isfile(file_path):
                age = now - os.path.getmtime(file_path)
                if age > max_age_seconds:
                    if NUKE_DRY_RUN:
                        print(f"would delete: {file_path}")
                    else:
                        os.remove(file_path)
                        print(f"deleted: {file_path}")


def nuke_spec(spec, data_path, config_path, dry_run):
    """Remove paths matching a spec. Supports * suffix for starts-with pattern."""
    if spec.startswith("data:"):
        base_path = data_path
        pattern = spec[5:]
    elif spec.startswith("config:"):
        base_path = config_path
        pattern = spec[7:]
    else:
        print(f"clean: invalid spec '{spec}', must start with 'data:' or 'config:'")
        return

    def do_nuke(path):
        if dry_run:
            print(f"would deleted: {path}")
        else:
            rmdir(path) if os.path.isdir(path) else os.remove(path)
            print(f"deleted: {path}")

    if pattern.endswith("*"):
        # Starts-with pattern
        prefix = pattern[:-1]
        parent_dir = os.path.dirname(prefix) or "."
        name_prefix = os.path.basename(prefix)
        search_dir = os.path.join(base_path, parent_dir)

        if not os.path.isdir(search_dir):
            return

        for entry in os.listdir(search_dir):
            if entry.startswith(name_prefix):
                full_path = os.path.join(search_dir, entry)
                do_nuke(full_path)
    else:
        # Exact path
        full_path = os.path.join(base_path, pattern)
        if os.path.exists(full_path):
            do_nuke(full_path)


def apply():
    """Apply updated configurations."""
    info = read_info()
    data_path = get_std_data_path()
    config_path = get_std_config_path()

    for rel_path in info["shaft"]["data-paths"]:
        dir_path = os.path.join(data_path, rel_path)
        if not os.path.isdir(dir_path):
            os.makedirs(dir_path)
            print(f"created: {dir_path}")

    lazy = info["lazy"]
    lazy_path = os.path.join(data_path, lazy["data-path"])
    checkout_repo(lazy_path, lazy["repo"], lazy["tag"], False, None)

    claude = info["claude"]
    repo_path = os.path.join(data_path, claude["data-path"])
    local_path = os.path.join(config_path, claude["config-path"])
    patch_path = os.path.join(config_path, claude["patch"])
    sparse_paths = claude["sparse"]
    checkout_repo(repo_path, claude["repo"], claude["commit"], True, sparse_paths)
    if os.path.isfile(patch_path):
        apply_patch(patch_path, repo_path)
        print(f"applied patch: {patch_path}")
    rec_clone_paths(repo_path, local_path, sparse_paths)
    restore_work_tree(repo_path)


def merge():
    """Merge configurations of a part."""
    if len(sys.argv) < 3:
        print("merge: missing PART argument")
        usage()
        sys.exit(1)
    part = sys.argv[2]
    merge_funcs = {
        "claudecode": merge_claudecode,
    }
    if part not in merge_funcs:
        print(f"merge: unknown part '{part}'")
        sys.exit(1)
    merge_funcs[part]()


def merge_claudecode():
    """Merge claudecode configurations."""
    info = read_info()
    claude = info["claude"]

    data_path = get_std_data_path()
    config_path = get_std_config_path()

    repo_path = os.path.join(data_path, claude["data-path"])
    patch_path = os.path.join(config_path, claude["patch"])
    base_commit = claude["commit"]

    if not os.path.isdir(repo_path):
        print(f"merge claudecode: repo not found at {repo_path}")
        sys.exit(1)

    if is_worktree_dirty(repo_path):
        print(f"merge claudecode: dirty worktree at {repo_path}")
        sys.exit(1)

    result = subprocess.run(
        ["git", "-C", repo_path, "diff", base_commit, "HEAD"],
        capture_output=True,
        text=True,
        check=True,
    )

    with open(patch_path, "w") as f:
        f.write(result.stdout)

    print(f"patch written to {patch_path}")


def repack():
    """Pack local configurations for update."""
    info = read_info()
    claude = info["claude"]

    data_path = get_std_data_path()
    config_path = get_std_config_path()

    repo_path = os.path.join(data_path, claude["data-path"])
    local_path = os.path.join(config_path, claude["config-path"])
    patch_path = os.path.join(config_path, claude["patch"])
    base_commit = claude["commit"]
    sparse_paths = claude["sparse"]

    if not os.path.isdir(local_path):
        print(f"repack: local config not found at {local_path}")
        sys.exit(1)

    checkout_repo(repo_path, claude["repo"], base_commit, True, sparse_paths)
    rec_clone_paths(local_path, repo_path, sparse_paths)
    result = subprocess.run(
        ["git", "-C", repo_path, "diff"],
        capture_output=True,
        text=True,
        check=True,
    )
    if not result.stdout.strip():
        print("repack: no changes detected")
        return

    # Write the patch
    write_patch(patch_path, result.stdout)
    print(f"repack: patch written to {patch_path}")
    restore_work_tree(repo_path)


def usage():
    """Print usage information."""
    print((__doc__ or "").strip())

# === HELPERS =================================================================

def get_std_config_path():
    if sys.platform == "win32":
        local_app_data = os.environ.get("LOCALAPPDATA", "")
        return os.path.join(local_app_data, "nvim")
    else:
        return os.path.expanduser("~/.config/nvim")


def get_std_data_path():
    if sys.platform == "win32":
        local_app_data = os.environ.get("LOCALAPPDATA", "")
        return os.path.join(local_app_data, "nvim-data")
    else:
        return os.path.expanduser("~/.local/share/nvim")


def read_info():
    config_path = get_std_config_path()
    info_path = os.path.join(config_path, "info.json")
    with open(info_path, "r") as f:
        return json.load(f)


def rmdir(path):
    path = os.path.abspath(path)
    if not os.path.exists(path):
        return
    try:
        shutil.rmtree(path)
        return
    except Exception:
        pass
    if sys.platform == "win32":
        subprocess.run(
            ["powershell", "-NoLogo", "-NoProfile", "-Command", f"Remove-Item -Recurse -Force '{path}'"],
            check=True,
        )
    else:
        subprocess.run(["rm", "-rf", path], check=True)


def is_worktree_dirty(path):
    """Check if a git worktree has uncommitted changes."""
    result = subprocess.run(
        ["git", "-C", path, "status", "--porcelain"],
        capture_output=True,
        text=True,
    )
    return bool(result.stdout.strip())


def rec_clone_paths(src_base, dst_base, paths):
    """Clone paths from src_base to dst_base, deleting existing destinations."""
    for rel_path in paths:
        rel_dir = rel_path.rstrip("/")
        src_path = os.path.join(src_base, rel_dir)
        dst_path = os.path.join(dst_base, rel_dir)

        if not os.path.exists(src_path):
            print(f"rec_clone_paths: source not found: {src_path}")
            continue

        if os.path.exists(dst_path):
            rmdir(dst_path)

        shutil.copytree(src_path, dst_path)
        print(f"copied: {src_path} -> {dst_path}")


def write_patch(path, content):
    """Write patch content to file as bytes to preserve line endings."""
    if isinstance(content, str):
        content = content.encode("utf-8")
    if sys.platform == "win32":
        content = content.replace(b"\r\n", b"\n")
    with open(path, "wb") as f:
        f.write(content)


def apply_patch(patch_path, repo_path):
    """Apply a patch file to a repo. Handles CRLF issues on Windows."""
    result = subprocess.run(
        ["git", "-C", repo_path, "apply", patch_path],
        capture_output=True,
    )
    if result.returncode == 0:
        return

    if sys.platform == "win32":
        with open(patch_path, "rb") as f:
            content = f.read()
        if b"\r\n" in content:
            temp_patch = patch_path + ".tmp"
            try:
                write_patch(temp_patch, content)
                subprocess.run(
                    ["git", "-C", repo_path, "apply", temp_patch],
                    check=True,
                )
                return
            finally:
                if os.path.exists(temp_patch):
                    os.remove(temp_patch)

    # Re-raise the original error
    subprocess.run(
        ["git", "-C", repo_path, "apply", patch_path],
        check=True,
    )


def restore_work_tree(path):
    """Restore all uncommitted changes in a git worktree."""
    subprocess.run(
        ["git", "-C", path, "checkout", "."],
        check=True,
    )


def checkout_repo(path, repo, ref, shallow, sparse):
    path = os.path.abspath(path)
    repo = f"https://github.com/{repo}"
    if os.path.exists(path):
        if is_worktree_dirty(path):
            print(f"checkout_repo: unclean work tree at {path}")
            exit(1)
    else:
        if shallow:
            os.makedirs(path)
            subprocess.run(["git", "-C", path, "init"], check=True)
            subprocess.run(
                ["git", "-C", path, "remote", "add", "origin", repo],
                check=True,
            )
        else:
            subprocess.run(["git", "clone", repo, path], check=True)

    if sparse:
        subprocess.run(
            ["git", "-C", path, "config", "core.sparseCheckout", "true"],
            check=True,
        )
        sparse_file = os.path.join(path, ".git", "info", "sparse-checkout")
        os.makedirs(os.path.dirname(sparse_file), exist_ok=True)
        with open(sparse_file, "w") as f:
            f.write("\n".join(sparse) + "\n")

    subprocess.run(
        ["git", "-C", path, "config", "advice.detachedHead", "false"],
        check=True,
    )

    if shallow:
        subprocess.run(["git", "-C", path, "fetch", "--depth", "1", "origin", ref], check=True,)
        subprocess.run(["git", "-C", path, "checkout", "FETCH_HEAD"], check=True,)
    else:
        subprocess.run(["git", "-C", path, "fetch", "origin"], check=True,)
        subprocess.run(["git", "-C", path, "checkout", ref], check=True,)


if __name__ == "__main__":
    main()
