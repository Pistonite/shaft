local M = {}

-- editorapi is used to determine state and integration for the editor
vim.api.nvim_create_user_command("EditorDebug", function()
    M.print_state()
end, {})

-- ENUMS

M.tabt = {
    INVALID = 0xff00,
    EDIT = 0x0100,     -- MainEdit: NvimTree and 1 or 2 opened file buffers
    AI_DIFF = 0x0200,   -- AiDiff:   Viewing diff generated by AI in a different tabpage
    DIFF = 0x0300,     -- MainDiff: Viewing diff explorer and 2 or 3 way diff
    SPECIAL = 0xfe00,   -- Other Stuff
}

M.wint = {
    INVALID = 0xff00,
    SPECIAL = 0xfe00,
    NTREE = 0x0101,     -- NvimTree
    NFILE = 0x0102,     -- Normal File
    NTERM = 0x0103,     -- Normal Terminal
    NOTIF = 0x0110,     -- Notification Window
    FLOAT = 0x0111,     -- Floating Window
    TELES = 0x0112,     -- Telescope
    TSCTX = 0x0122,     -- Treesitter Context
    AIFILE = 0x0201,    -- Original file in AI Diff
    AIDIFF = 0x0202,    -- Proposed change in AI Diff
    DTREE = 0x0301,     -- Tree in diff view
    DFILE = 0x0302,     -- In diff view, the file (not sure how to detect "old" vs "new", should be a way)
}
local wint2tabt = function(wint) return bit.band(wint, 0xff00) end

local function enumname(value)
    for name, v in pairs(M.wint) do
        if v == value then return name end
    end
    for name, v in pairs(M.tabt) do
        if v == value then return name end
    end
    return tostring(value)
end

-- AUTOCOMMANDS ========================================================================

M.s_enable_nterm_autofocus = true
vim.api.nvim_create_autocmd("BufEnter", {
    callback = function()
        -- cannot save cache when query, because BufEnter
        -- can be called very early before NvimTree is setup
        local wint = M.query_wint(nil, true)

        if wint == M.wint.NTERM then
            -- this is needed to prevent focusing too early when switching tabs
            if M.s_enable_nterm_autofocus then
                vim.cmd("startinsert")
            end
            return
        end
        if wint == M.wint.AIDIFF then
            local current_buf = vim.api.nvim_get_current_buf()
            for _, winid in ipairs(vim.api.nvim_tabpage_list_wins(0)) do
                local bufnr = vim.api.nvim_win_get_buf(winid)
                if bufnr ~= current_buf then
                    local ft = vim.bo[bufnr].filetype
                    if ft and ft ~= "" then
                        vim.bo[current_buf].filetype = ft
                        break
                    end
                end
            end
        end

    end
})
vim.api.nvim_create_autocmd("VimLeavePre", {
    callback = function()
        for _, bufnr in ipairs(vim.api.nvim_list_bufs()) do
            if vim.bo[bufnr].buftype == "terminal" then
                vim.api.nvim_buf_delete(bufnr, { force = true })
            end
        end
    end
})

-- STATES
-- making editorapi stateful for better performance. for example,
-- avoids recomputing window types and tabpage types

M.s_tabts = {} -- tabpage id -> tabt
M.s_tabmp = {} -- tabt -> tagpage id
M.s_wints = {} -- window id -> wint
function M.print_state()
    local tabts_str = {}
    for tabid, tabt in pairs(M.s_tabts) do
        tabts_str[tabid] = enumname(tabt)
    end
    local tabmp_str = {}
    for tabt, tabid in pairs(M.s_tabmp) do
        tabmp_str[enumname(tabt)] = tabid
    end
    local wints_str = {}
    for winid, wint in pairs(M.s_wints) do
        wints_str[winid] = enumname(wint)
    end
    local msg = "s_tabts=" .. vim.inspect(tabts_str) .. "\ns_tabmp="..vim.inspect(tabmp_str).."\ns_wints="..vim.inspect(wints_str)
    local filewins, _ = M.editview_query_file_windows()
    local filewins_tb = {}
    for _, winid in ipairs(filewins) do
        local bufnr = vim.api.nvim_win_get_buf(winid)
        filewins_tb[winid] = "bufnr "..bufnr.." ft:"..vim.bo.filetype.." bt:"..vim.bo.buftype.." name:"..vim.api.nvim_buf_get_name(bufnr).." undolevels:"..vim.bo[bufnr].undolevels
    end
    msg = msg .. "\nfilewins=" .. vim.inspect(filewins_tb)
    vim.api.nvim_echo({{ msg, "Normal" }}, true, {})
end

local wints_ops = 0
function M.clean_state(force)
    if wints_ops < 100 and not force then
        return
    end
    wints_ops = 0
    local to_remove = {}
    for tabid, _ in pairs(M.s_tabts) do
        if not vim.api.nvim_tabpage_is_valid(tabid) then
            table.insert(to_remove, tabid)
        end
    end
    for _, tabid in ipairs(to_remove) do
        M.s_tabts[tabid] = nil
    end
    if #to_remove > 0 then
        M.s_tabmp = {}
        for tabid, tabt in pairs(M.s_tabts) do
            M.s_tabmp[tabt] = tabid
        end
    end
    to_remove = {}
    for winid, _ in pairs(M.s_wints) do
        if not vim.api.nvim_win_is_valid(winid) then
            table.insert(to_remove, winid)
        end
    end
    for _, winid in ipairs(to_remove) do
        M.s_wints[winid] = nil
    end
end

---Get the tabpage id if exists, or nil
function M.query_tabid(tabt)
    local tabid = M.s_tabmp[tabt]
    if tabid ~= nil then
        local t = M.query_tabt(tabid)
        if t == tabt then
            return tabid
        end
        M.s_tabmp[tabt] = nil
    end
    for _, tabid2 in ipairs(vim.api.nvim_list_tabpages()) do
        local t = M.query_tabt(tabid2)
        if t ~= M.tabt.INVALID then
            M.s_tabmp[t] = tabid2
        end
    end
    return M.s_tabmp[tabt]
end

---Get the type of a window
---@param winid integer | nil window id
---@param no_save_cache boolean | nil don't save cache (can use cached value)
function M.query_wint(winid, no_save_cache)
    if winid == 0 or winid == nil then
        winid = vim.api.nvim_get_current_win()
    else
        if not vim.api.nvim_win_is_valid(winid) then
            M.s_wints[winid] = nil
            return M.wint.INVALID
        end
    end
    local w = M.s_wints[winid]
    if w ~= nil then
        return w
    end
    w = M.calc_wint(winid, no_save_cache or false)
    if not no_save_cache then
        M.s_wints[winid] = w
    end
    wints_ops = wints_ops + 1
    M.clean_state(false)
    return w
end

---Calculate type of window
---@param winid integer valid window id
---@param no_save_cache boolean don't save cache (can use cached value)
function M.calc_wint(winid, no_save_cache)
    local fast_wint = M.calc_wint_fast(winid)
    if fast_wint ~= M.wint.INVALID then return fast_wint end

    local tabid = vim.api.nvim_win_get_tabpage(winid)
    local tabtype = M.query_tabt(tabid, no_save_cache)
    if tabtype == M.tabt.EDIT then
        return M.wint.NFILE
    end
    if tabtype == M.tabt.AI_DIFF then return M.wint.AIFILE end
    return M.wint.DFILE
end

---Get the type of a tabpage
---@param tabid integer | nil tabpage id
---@param no_save_cache boolean | nil don't save cache (can use cached value)
function M.query_tabt(tabid, no_save_cache)
    if tabid == 0 or tabid == nil then
        tabid = vim.api.nvim_get_current_tabpage()
    else
        if not vim.api.nvim_tabpage_is_valid(tabid) then
            M.s_tabmp[M.s_tabts[tabid]] = nil
            M.s_tabts[tabid] = nil
            -- default to edit
            return M.tabt.INVALID
        end
    end
    local x = M.s_tabts[tabid]
    if x ~= nil then -- previous queried, assume it's still valid
        return x
    end
    x = M.calc_tabt(tabid)
    if not no_save_cache then
        M.s_tabts[tabid] = x
        M.s_tabmp[x] = tabid
    end
    return x
end

---Calculate type of tabpage
---@param tabid integer valid tabpage id
function M.calc_tabt(tabid)
    for _, winid in ipairs(vim.api.nvim_tabpage_list_wins(tabid)) do
        local fast_wint = M.calc_wint_fast(winid)
        if fast_wint ~= M.wint.INVALID then return wint2tabt(fast_wint) end
    end
    -- default to edit view (for example, editing single file)
    return M.tabt.EDIT
end

function M.calc_wint_fast(winid)
    local bufnr = vim.api.nvim_win_get_buf(winid)

    local filetype = vim.bo[bufnr].filetype
    if filetype == "NvimTree"          then return M.wint.NTREE end
    if filetype == "codediff-explorer" then return M.wint.DTREE end
    if filetype == "claude-notify"     then return M.wint.NOTIF end
    if filetype == "floaterm"          then return M.wint.FLOAT end
    if filetype == "lazy"              then return M.wint.SPECIAL end
    if filetype == "mason"             then return M.wint.SPECIAL end

    local buftype = vim.bo[bufnr].buftype
    if buftype == "terminal"           then return M.wint.NTERM end
    if string.find(filetype, "Telescope") then
        return M.wint.TELES
    end
    local bufname = vim.api.nvim_buf_get_name(bufnr)
    if M.aicoder_is_diff_bufname(bufname) then
        return M.wint.AIDIFF
    end
    -- HACK: Treesitter Context
    if bufname == "" and vim.bo[bufnr].undolevels == -1 then
        return M.wint.TSCTX
    end

    return M.wint.INVALID
end

-- VIEW CHANGE =====================================================================

function M.editview_open_split()
    local tabt = M.query_tabt()
    if tabt ~= M.tabt.EDIT then return end
    if vim.bo.buftype == "terminal" then return end -- faster query

    local filewins, termwins = M.editview_query_file_windows()
    for _, winid in ipairs(termwins) do
        vim.api.nvim_win_hide(winid)
    end

    local tree = require("nvim-tree.api")
    if #filewins < 2 then
        tree.node.open.vertical()
    else
        tree.node.open.edit()
    end
end

---Swap the 2 files in edit view
function M.editview_swap_files()
    local tabt = M.query_tabt()
    if tabt ~= M.tabt.EDIT then return end
    if vim.bo.buftype == "terminal" then return end -- faster query

    local filewins, _ = M.editview_query_file_windows()
    if #filewins ~= 2 then return end
    -- must use win_splitmove, otherwise it will not work
    -- if both windows have the same buffer
    local x_1 = vim.api.nvim_win_get_position(filewins[1])[2]
    local x_2 = vim.api.nvim_win_get_position(filewins[2])[2]
    local win_left, win_right
    if x_1 < x_2 then
        win_left = filewins[1]
        win_right = filewins[2]
    else
        win_left = filewins[2]
        win_right = filewins[1]
    end
    vim.fn.win_splitmove(win_right, win_left, { vertical = true })
end

---Duplicate the focused view in edit view
---@param right boolean if true, end up in the right window
function M.editview_duplicate(right)
    local tabt = M.query_tabt()
    if tabt ~= M.tabt.EDIT then return end
    if vim.bo.buftype == "terminal" then return end -- faster query

    local filewins, termwins = M.editview_query_file_windows()
    for _, winid in ipairs(termwins) do
        vim.api.nvim_win_hide(winid)
    end
    local windows_len = #filewins
    if windows_len == 1 then
        local curr_winid = vim.api.nvim_get_current_win()
        if curr_winid ~= filewins[1] then
            vim.api.nvim_set_current_win(filewins[1])
        end
        if right then vim.api.nvim_input('<C-w>v<C-W>l') else vim.api.nvim_input('<C-w>v') end
        return
    end
    if windows_len == 2 then
        -- we don't use split here to avoid motion sickness
        local curr_winid = vim.api.nvim_get_current_win()
        local other_winid
        if curr_winid == filewins[1] then
            other_winid = filewins[2]
        elseif curr_winid == filewins[2] then
            other_winid = filewins[1]
        else
            return
        end
        local bufnr = vim.api.nvim_win_get_buf(curr_winid)
        local cursor = vim.api.nvim_win_get_cursor(curr_winid)
        local screenrow = vim.fn.screenpos(curr_winid, cursor[1], cursor[2]).row
        local height = vim.api.nvim_win_get_height(other_winid)

        local new_cursor_row_for_view = cursor[1] - screenrow + math.floor((height+1)/2)
        local bufnr_lc = vim.api.nvim_buf_line_count(bufnr)
        local need_fixview = new_cursor_row_for_view <= bufnr_lc

        local x_1 = vim.api.nvim_win_get_position(curr_winid)[2]
        local x_2 = vim.api.nvim_win_get_position(other_winid)[2]
        local need_focus = (x_1 < x_2) == right

        vim.api.nvim_win_set_buf(other_winid, bufnr)
        if need_fixview then
            vim.api.nvim_win_set_cursor(other_winid, { new_cursor_row_for_view, cursor[2] })
            vim.fn.win_execute(other_winid, "normal! zz")
        end
        if need_focus then
            vim.api.nvim_set_current_win(other_winid)
        end
        -- need to set cursor in the end to proper trigger cursor move (like TS context)
        vim.api.nvim_win_set_cursor(other_winid, cursor)
        return
    end
    M.warn("editview_duplicate: too many file windows")
end

---If in floaterm, close floaterm
---Otherwise switch to EDIT and show floaterm
function M.editview_floaterm_toggle()
    local wint = M.query_wint()
    if wint == M.wint.FLOAT then
        vim.cmd.FloatermToggle()
        return
    end
    if wint == M.wint.SPECIAL then return end
    local tabid = M.query_tabid(M.tabt.EDIT)
    if tabid == vim.api.nvim_get_current_tabpage() then -- if we are on edit view then toggle terminal
        vim.cmd.FloatermToggle()
        return
    end
    -- switch to edit view and show/focus on terminal
    vim.api.nvim_set_current_tabpage(tabid)
    wint = M.query_wint()
    if wint == M.wint.FLOAT then -- already focused
        return
    end
    for _, winid in ipairs(vim.api.nvim_tabpage_list_wins(tabid)) do
        wint = M.query_wint(winid)
        if wint == M.wint.FLOAT then
            local curr_winid = vim.api.nvim_get_current_win()
            if curr_winid ~= winid then
                vim.api.nvim_set_current_win(curr_winid)
                return
            end
        end
    end
    -- did not find floaterm, toggle it
    vim.cmd.FloatermToggle()
end


---If in floaterm, make a new terminal instance
function M.editview_floaterm_new()
    local wint = M.query_wint()
    if wint == M.wint.FLOAT then
        vim.cmd.FloatermNew()
    end
end

---If in floaterm, cycle between the terminals
function M.editview_floaterm_cycle()
    local wint = M.query_wint()
    if wint == M.wint.FLOAT then
        vim.cmd.FloatermNext()
    end
end

---Action to escape active terminal
---If in NTERM, it will ready to switch focus
---If in FLOAT, it will switch to normal mode
function M.editview_terminal_escape()
    local wint = M.query_wint()
    if wint == M.wint.FLOAT then
        vim.cmd("stopinsert")
        return
    end
    if wint == M.wint.NTERM then
        vim.cmd("stopinsert")
        -- also execute another C-w to be ready to switch focus
        vim.api.nvim_input("<C-w>")
    end
end

-- VIEW CHANGE / Telescope =====================================================================

local telescope_opened_wint = M.wint.INVALID
local telescope_attach_file_picker_mappings = function(bufnr, _)
    if telescope_opened_wint == M.wint.NFILE or telescope_opened_wint == M.wint.INVALID then
        return true
    end
    local actions = require "telescope.actions"
    local action_state = require "telescope.actions.state"
    if telescope_opened_wint == M.wint.NTERM then
        actions.select_default:replace(function()
            actions.close(bufnr)
            local selection = action_state.get_selected_entry()
            vim.cmd("ClaudeCodeAdd " .. selection[1])
            vim.defer_fn(function()
                M.editview_aicoder_open()
            end, 50)
        end)
    else
        actions.select_default:replace(function()
            actions.close(bufnr)
            local selection = action_state.get_selected_entry()
            local ntree_actions = require("nvim-tree.actions")
            -- manually call nvim tree action to avoid the tree being closed and re-opened
            -- causing motion sickness
            ntree_actions.node.open_file.fn("", selection[1])
        end)
    end
    return true
end

function M.editview_openfinder_last()
    local wint = M.query_wint()
    if wint == M.wint.TELES then return end
    if wint == M.wint.SPECIAL then return end
    telescope_opened_wint = wint
    M.editview_normalize(false)
    vim.cmd("Telescope resume")
end

function M.editview_openfinder_file()
    local wint = M.query_wint()
    if wint == M.wint.TELES then return end
    if wint == M.wint.SPECIAL then return end
    telescope_opened_wint = wint
    M.editview_normalize(false)
    require('telescope.builtin').find_files {
        attach_mappings = telescope_attach_file_picker_mappings
    }
end

function M.editview_openfinder_live_grep()
    local wint = M.query_wint()
    if wint == M.wint.TELES then return end
    if wint == M.wint.SPECIAL then return end
    telescope_opened_wint = wint
    M.editview_normalize(false)
    require('telescope.builtin').live_grep {
        attach_mappings = telescope_attach_file_picker_mappings
    }
end

function M.editview_openfinder_buffer()
    local wint = M.query_wint()
    if wint == M.wint.TELES then return end
    if wint == M.wint.SPECIAL then return end
    telescope_opened_wint = wint
    M.editview_normalize(false)
    require('telescope.builtin').buffers {
        attach_mappings = telescope_attach_file_picker_mappings
    }
end

function M.editview_openfinder_symbol()
    local wint = M.query_wint()
    if wint == M.wint.TELES then return end
    if wint == M.wint.SPECIAL then return end
    telescope_opened_wint = M.wint.INVALID
    M.editview_normalize(false)
    require("telescope.builtin").treesitter()
end

function M.editview_openfinder_definition()
    local wint = M.query_wint()
    if wint == M.wint.TELES then return end
    if wint == M.wint.SPECIAL then return end
    telescope_opened_wint = M.wint.INVALID
    M.editview_normalize(false)
    require("telescope.builtin").lsp_definitions()
end

function M.editview_openfinder_reference()
    local wint = M.query_wint()
    if wint == M.wint.TELES then return end
    if wint == M.wint.SPECIAL then return end
    telescope_opened_wint = M.wint.INVALID
    M.editview_normalize(false)
    require("telescope.builtin").lsp_references()
end

function M.editview_openfinder_implementation()
    local wint = M.query_wint()
    if wint == M.wint.TELES then return end
    if wint == M.wint.SPECIAL then return end
    telescope_opened_wint = M.wint.INVALID
    M.editview_normalize(false)
    require("telescope.builtin").lsp_implementations()
end

function M.editview_openfinder_diagnostic()
    local wint = M.query_wint()
    if wint == M.wint.TELES then return end
    if wint == M.wint.SPECIAL then return end
    telescope_opened_wint = M.wint.INVALID
    M.editview_normalize(false)
    require("telescope.builtin").diagnostics({ bufnr = 0})
end

-- VIEW CHANGE / AI Coder =====================================================================

local is_aicoder_installed = nil
local was_aicoder_focused_when_aidiff_open = false
local just_accepted_aidiff = false
---Switch to EDIT and open AI Coder
function M.editview_aicoder_open()
    if is_aicoder_installed == nil then
        is_aicoder_installed = vim.fn.executable("claude") == 1
    end
    if not is_aicoder_installed then
        M.warn("aicoder is not installed on this system")
        return
    end
    local wint = M.query_wint()
    if wint == M.wint.NTERM then return end
    if wint == M.wint.SPECIAL then return end

    M.editview_normalize(false)
    local tabid = M.query_tabid(M.tabt.EDIT)
    local filewins, termwins = M.editview_query_file_windows(tabid)
    if #termwins > 0 then -- just focus on the first
        vim.api.nvim_set_current_win(termwins[1])
        return
    end
    local filewins_len = #filewins
    if filewins_len == 0 then -- will mess up the view if open ai coder first
        M.warn("cannot open aicoder when no file in view")
        return
    end
    local curr_winid = vim.api.nvim_get_current_win()
    vim.cmd.ClaudeCode() -- open to let it load first
    if filewins_len == 1 then
        -- find the ai coder terminal
        for _, winid in ipairs(vim.api.nvim_tabpage_list_wins(tabid)) do
            if M.query_wint(winid) == M.wint.NTERM then
                vim.fn.win_splitmove(curr_winid, winid, { vertical = true })
                break
            end
        end
        return
    end
    if filewins_len == 2 then
        if curr_winid == filewins[1] then
            vim.api.nvim_win_hide(filewins[2])
        elseif curr_winid == filewins[2] then
            vim.api.nvim_win_hide(filewins[1])
        else
            -- close the one on the right
            local x_1 = vim.api.nvim_win_get_position(filewins[1])[2]
            local x_2 = vim.api.nvim_win_get_position(filewins[2])[2]
            if x_1 < x_2 then
                vim.api.nvim_win_hide(filewins[2])
                curr_winid = filewins[1]
            else
                vim.api.nvim_win_hide(filewins[1])
                curr_winid = filewins[2]
            end
        end
        -- find the ai coder terminal
        for _, winid in ipairs(vim.api.nvim_tabpage_list_wins(tabid)) do
            if M.query_wint(winid) == M.wint.NTERM then
                vim.fn.win_splitmove(curr_winid, winid, { vertical = true })
                break
            end
        end
        return
    end
    M.warn("editview_open_aicoder: too many file windows")
end

---Close AI Coder UI when in EDIT view
---Or close AI Coder Diff when in AIDiff view
function M.aicoder_close()
    local tabt = M.query_tabt()
    if tabt == M.tabt.AI_DIFF then
        local tabid = M.query_tabid(M.tabt.EDIT)
        vim.api.nvim_set_current_tabpage(tabid)
        return
    end
    if tabt == M.tabt.EDIT then
        for _, winid in ipairs(vim.api.nvim_list_wins()) do
            if M.query_wint(winid) == M.wint.NTERM then
                vim.api.nvim_win_hide(winid)
            end
        end
        vim.cmd.ClaudeCodeNotificationDismiss()
        return
    end
end

function M.aicoder_check_auto_open_diff()
    if just_accepted_aidiff or M.aicoder_is_focused() then
        was_aicoder_focused_when_aidiff_open = true
        return true
    end
    was_aicoder_focused_when_aidiff_open = false
    return false
end

---If not looking at AIDiff, open it
---Otherwise accept it
function M.aicoder_open_or_accept_diff()
    local _wint = M.query_wint();
    if _wint == M.wint.SPECIAL then return end

    local tabid = M.query_tabid(M.tabt.AI_DIFF)
    if tabid ~= nil then
        local curr_tabid = vim.api.nvim_get_current_tabpage()
        if curr_tabid == tabid then
            -- accept
            -- make sure no unsaved modifications in all opened windows
            for _, winid in ipairs(vim.api.nvim_tabpage_list_wins(0)) do
                local wint = M.query_wint(winid)
                if wint == M.wint.AIDIFF or wint == M.wint.AIFILE then
                    local bufnr = vim.api.nvim_win_get_buf(winid)
                    if vim.bo[bufnr].modified then
                        M.warn("diff is unsaved, must save before accepting")
                        return
                    end
                end
            end
            local should_focus = was_aicoder_focused_when_aidiff_open
            just_accepted_aidiff = true
            -- close the aidiff
            vim.cmd(vim.api.nvim_tabpage_get_number(tabid) .. "tabclose")
            -- switch to edit
            local edit_tabid = M.query_tabid(M.tabt.EDIT)
            M.s_enable_nterm_autofocus = false
            vim.api.nvim_set_current_tabpage(edit_tabid)
            -- close any dangling aidiff buffers if needed
            for _, bufnr in ipairs(vim.api.nvim_list_bufs()) do
                local bufname = vim.api.nvim_buf_get_name(bufnr)
                if M.aicoder_is_diff_bufname(bufname) then
                    vim.api.nvim_buf_delete(bufnr, {force=false})
                end
            end
            vim.cmd.ClaudeCodeDiffAccept()
            if should_focus then
                -- defer to realize the tab switch
                vim.defer_fn(function()
                    M.s_enable_nterm_autofocus = true
                    M.editview_aicoder_open()
                    M.warn("accepted aidiff")
                    vim.defer_fn(function()
                        just_accepted_aidiff = false
                    end, 500)
                end, 50)
            else
                M.warn("accepted aidiff")
                vim.defer_fn(function()
                    M.s_enable_nterm_autofocus = true
                end, 500)
            end
        else
            -- open existing
            was_aicoder_focused_when_aidiff_open = M.aicoder_is_focused()
            vim.api.nvim_set_current_tabpage(tabid)
        end
        return
    end
    -- open new
    was_aicoder_focused_when_aidiff_open = M.aicoder_is_focused()
    vim.cmd.ClaudeCodeOpenCodeDiff()
end

function M.aicoder_deny_diff()
    local _wint = M.query_wint();
    if _wint == M.wint.SPECIAL then return end
    -- note we allow denying without the diff open
    -- say we forgot some instruction and want to deny the output
    -- without checking
    local should_focus = M.query_wint() == M.wint.NTERM
    local aidiff_tabid = M.query_tabid(M.tabt.AI_DIFF)
    should_focus = should_focus or vim.api.nvim_get_current_tabpage() == aidiff_tabid
    M.s_enable_nterm_autofocus = false
    local tab_switched = M.editview_normalize(false)
    -- force close the diff buffers
    for _, bufnr in ipairs(vim.api.nvim_list_bufs()) do
        local bufname = vim.api.nvim_buf_get_name(bufnr)
        if M.aicoder_is_diff_bufname(bufname) then
            vim.api.nvim_buf_delete(bufnr, {force=true})
        end
    end
    if aidiff_tabid ~= nil then
        vim.cmd(vim.api.nvim_tabpage_get_number(aidiff_tabid) .. "tabclose")
    end
    vim.cmd.ClaudeCodeDiffDeny()
    if tab_switched then
        -- defer to realize the tab switch
        vim.defer_fn(function()
            M.s_enable_nterm_autofocus = true
            if should_focus then
                M.editview_aicoder_open()
            end
            M.warn("denied aidiff")
        end, 50)
    else
        M.s_enable_nterm_autofocus = true
        if should_focus then
            M.editview_aicoder_open()
        end
        M.warn("denied aidiff")
    end
end


---Send context to AI Coder
---@param visual boolean if in visual mode
function M.aicoder_send(visual)
    local tabt = M.query_tabt()
    if tabt ~= M.tabt.EDIT then
        M.warn("can only send to aicoder in edit view")
        return
    end
    local wint = M.query_wint()
    if wint == M.wint.NTREE then
        if visual then return end
        -- send file in tree
        vim.cmd.ClaudeCodeTreeAdd()
        M.editview_aicoder_open()
        return
    end
    if wint ~= M.wint.NFILE then
        return
    end
    if visual then
        vim.api.nvim_input("gv<cmd>ClaudeCodeSend<cr>")
    else
        vim.cmd("ClaudeCodeAdd %")
    end
    -- need to defer to realize the send above first
    vim.defer_fn(function()
        M.editview_aicoder_open()
    end, 200)
end

function M.aicoder_is_diff_bufname(bufname)
    return bufname:match("%.claude%-proposed") ~= nil
end

---Check if currently focused on aicoder (in the right buffer and terminal mode)
function M.aicoder_is_focused()
    if vim.api.nvim_get_mode().mode == "t" then
        if M.query_wint() == M.wint.NTERM then
            return true
        end
    end
    return false
end

-- VIEW CHANGE / Helpers =====================================================================

---List NFILE window ids in the edit view
---@param tabid integer | nil, the EDIT tabid, 0 to use current tab
function M.editview_query_file_windows(tabid)
    local files = {}
    local terms = {}
    for _, winid in ipairs(vim.api.nvim_tabpage_list_wins(tabid or 0)) do
        local wint = M.query_wint(winid)
        if wint == M.wint.NFILE then
            table.insert(files, winid)
        elseif wint == M.wint.NTERM then
            table.insert(terms, winid)
        end
    end
    return files, terms
end

--- Ensure a "normal" editing state
--- If in edit view, it will make sure either NTREE or NFILE is focused
--- If in other view, it will switch the tabpage to edit
---@param allow_nterm boolean if true, allow nterm to be focused
---@return boolean true if tabpage is switched
function M.editview_normalize(allow_nterm)
    local tabid = M.query_tabid(M.tabt.EDIT)
    local curr_tabid = vim.api.nvim_get_current_tabpage()
    local result = false
    if tabid ~= curr_tabid then
        vim.api.nvim_set_current_tabpage(tabid)
        result = true
    end
    local wint = M.query_wint()
    while wint == M.wint.FLOAT or wint == M.wint.TELES do
        if wint == M.wint.FLOAT then
            vim.cmd.FloatermToggle()
        elseif wint == M.wint.TELES then
            vim.cmd("stopinsert")
            vim.cmd("normal! <esc>")
        end
        wint = M.query_wint()
    end
    if wint == M.wint.NTERM and not allow_nterm then
        -- find a window in editview to focus
        local ntree_winid = nil
        local focused = false
        for _, winid in ipairs(vim.api.nvim_tabpage_list_wins(tabid)) do
            wint = M.query_wint(winid)
            if wint == M.wint.NTREE then
                ntree_winid = winid
            end
            if wint == M.wint.NFILE then
                focused = true
                -- just set since NFILE and NTERM can't be the same window
                vim.api.nvim_set_current_win(winid)
                break
            end
        end
        if not focused then
            if ntree_winid then
                vim.api.nvim_set_current_win(ntree_winid)
            end
        end
    end
    return result
end

-- Diff =====================================================================

--- View existing git diff, or open git status
function M.diffview_git_view_or_status()
    local _wint = M.query_wint();
    if _wint == M.wint.SPECIAL then return end
    local tabid = M.query_tabid(M.tabt.DIFF)
    if tabid ~= nil then
        vim.api.nvim_set_current_tabpage(tabid)
        return;
    end
    vim.cmd.CodeDiff()
end

--- Prompt for revs for diff
function M.diffview_git_diff_new()
    local _wint = M.query_wint()
    if _wint == M.wint.SPECIAL then return end
    local tabid = M.query_tabid(M.tabt.DIFF)
    if tabid ~= nil then
        vim.cmd(vim.api.nvim_tabpage_get_number(tabid) .. "tabclose")
    end
    vim.ui.input({ prompt = 'Git diff ( [OLD] or [OLD..NEW] ): ' }, function(input)
        if input then
            -- A..B: diff from commit A to commit B
            -- A: (just the commit/branch name)
            if input:find("%.%.") then
                local a, b = input:match("(.+)%.%.(.+)")
                if a and b then
                    vim.cmd("CodeDiff " .. a .. " " .. b)
                end
            else
                vim.cmd("CodeDiff " .. input)
            end
        end
    end)
end

--- Open/Focus file tree
---@param sync boolean if true, sync the file in an already opened tree (NTree only)
function M.open_file_tree(sync)
    local _wint = M.query_wint()
    if _wint == M.wint.SPECIAL then return end
    local tabt = M.query_tabt()
    if tabt == M.tabt.EDIT then
        if sync then
            require('nvim-tree.api').tree.find_file()
            vim.defer_fn(vim.cmd.NvimTreeFocus, 50)
        else
            vim.cmd.NvimTreeOpen()
        end
        return
    end
    if tabt == M.tabt.DIFF then
        vim.api.nvim_input("<C-w>h<C-w>h")
        vim.defer_fn(function()
            if M.query_wint() ~= M.wint.DTREE then
                vim.api.nvim_input("<leader>pT<C-w>h")
            end
        end, 50)
    end
end

function M.multipurpose_toggle_shift_i()
    local wint = M.query_wint()
    if wint == M.wint.NTREE then
        require("nvim-tree.api").tree.toggle_gitignore_filter()
        return
    end
    if wint2tabt(wint) == M.tabt.EDIT then
        -- toggle show hidden characters (like eol, tab, etc.)
        vim.o.list = not vim.o.list
        return
    end
end

-- PURE ACTIONS ==========================================================================

---Jump to next '_', uppercase letter, or word boundary in the current buffer
---@param action string | nil d for delete and c for change
---@param flag   string | nil flag for the action, "f" or "t" (find or til)
function M.jump_half_word(action, flag)
    -- Save current position
    local row, col = unpack(vim.api.nvim_win_get_cursor(0))
    -- Search pattern: _ or [A-Z] or word boundary (\<)
    local pattern = [[\(_\w\|\u\|\<\)]]
    -- Search forward, no [W]rap and go to [e]nd
    local found = vim.fn.search(pattern, 'We')
    if found == 0 then
        -- Not found, restore cursor
        vim.api.nvim_win_set_cursor(0, {row, col})
        return
    end
    if action == nil then
        return
    end
    if action == 'd' or action == 'c' then
        local new_row, new_col = unpack(vim.api.nvim_win_get_cursor(0))
        vim.api.nvim_win_set_cursor(0, {row, col})
        -- enter visual mode
        vim.cmd('normal! v')
        if flag == 't' then
            vim.api.nvim_win_set_cursor(0, {new_row, new_col - 1})
        else
            vim.api.nvim_win_set_cursor(0, {new_row, new_col})
        end
        vim.cmd('normal! d')
        if action == 'c' then
            vim.cmd('startinsert')
        end
        return
    end
end

---Jump to dianostic
---@param count integer      -1 for previous, 1 for next
---@param error_only boolean filter to only errors
function M.jump_diagnostic(count, error_only)
    if error_only then
        vim.diagnostic.jump({ count = count, severity = vim.diagnostic.severity.ERROR })
    else
        vim.diagnostic.jump({ count = count })
    end
    -- show diagnostic window
    vim.defer_fn(function()
        vim.diagnostic.open_float({ scope = 'cursor' })
    end, 50)
end

---Fix issues in the buffer, such as highlighting and diagnostics
function M.fix_buffer_issues(restart_lsp)
    local bufnr = vim.api.nvim_get_current_buf()
    if vim.bo[bufnr].modified then
        M.warn("please save the file first")
        return
    end
    local line_count = vim.api.nvim_buf_line_count(bufnr)
    -- trigger some change to force lsp rethink
    vim.api.nvim_buf_set_lines(bufnr, line_count, line_count, false, { "" })
    vim.cmd("silent! write!")
    -- get rid of stale diagnostics
    vim.diagnostic.reset(nil, bufnr)
    -- undo the change
    vim.api.nvim_buf_set_lines(bufnr, line_count, line_count + 1, false, {})
    vim.cmd("silent! write!")
    vim.cmd("edit")
    if restart_lsp then
        vim.cmd.LspRestart()
    end
    M.warn("buffer reset")
end

---Yank to Host
local _ = (function()
    local yank_file = vim.fn.stdpath('data') .. '/.yank'
    local yank_file_quoted = vim.fn.shellescape(yank_file)
    local cmd
    local check_cmd
    local desc = "yanking to host is not supported on the current setup"
    local check_desc

    if vim.fn.has("win32") ~= 0 then
        cmd = '(Get-Content ' .. yank_file_quoted .. ') -replace "`0","`n" | set-clipboard'
        desc = "yanked to host clipboard with powershell"
    elseif vim.env.SSH_CLIENT then
        if vim.fn.executable("websocat") == 0 then
            desc = "websocat is needed for yanking to ssh client over websocket"
        else
            local host_ip = vim.env.SSH_CLIENT:match("^(%d+%.%d+%.%d+%.%d+)")
            if not host_ip then
                desc = "SSH_CLIENT does not contain a valid IPv4 address"
            else
                local host_port = require("piston.config_gen").editorapi_ssh_wsclip_port
                check_cmd = 'timeout 2 bash -c "echo < /dev/tcp/' .. host_ip .. '/' .. host_port .. '"'
                check_desc = "ssh client port "..host_port.." is not reachable. please ensure wsclip is running"
                cmd = 'bash -c "cat ' .. yank_file_quoted .. ' | websocat -1 -t -u ws://' .. host_ip .. ':'..host_port..'"'
                desc = "yanked to ssh client wsclip"
            end
        end
    elseif vim.fn.executable("wl-copy") ~= 0 then
        cmd = 'bash -c "cat ' .. yank_file_quoted .. " | tr '\\0' '\\n' | wl-copy -n\""
            desc = "yanked to wayland"
    end

    vim.api.nvim_create_autocmd("TextYankPost", {
        callback = function()
            if vim.v.register ~= 'a' then
                return
            end
            if not cmd then
                M.warn(desc)
                return
            end
            if check_cmd then
                vim.fn.system(check_cmd)
                M.warn("yanking to host...")
                if vim.v.shell_error ~= 0 then
                    M.warn(check_desc)
                    return
                end
            end
            vim.fn.writefile({ vim.fn.getreg('a') }, yank_file)
            vim.fn.system(cmd)
            vim.cmd('redraw!')
            M.warn(desc)
        end,
    })
end)()

-- HELPERS =============================================================================


function M.warn(msg) vim.notify("editorapi: "..msg, vim.log.levels.WARN) end

return M
