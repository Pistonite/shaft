//! Starship shell prompt, with configurations

use crate::pre::*;

register_binaries!("starship");
version_cache!(static CFG_VERSION = metadata::starship::CFG_VERSION);
binary_dependencies!(CargoBinstall);
config_dependencies!(Terminal); // for clink

pub fn verify(_: &Context) -> cu::Result<Verified> {
    let v = check_cargo!("starship");
    check_outdated!(&v.version, metadata[starship]::VERSION);
    check_version_cache!(CFG_VERSION);
    Ok(Verified::UpToDate)
}

pub fn install(ctx: &Context) -> cu::Result<()> {
    epkg::cargo::binstall("starship", ctx.bar_ref())?;
    Ok(())
}

pub fn uninstall(_: &Context) -> cu::Result<()> {
    epkg::cargo::uninstall("starship")?;
    Ok(())
}

pub fn configure(ctx: &Context) -> cu::Result<()> {
    use std::fmt::Write as _;
    let mut config_file = String::new();
    let mut format = "$os$shell://$directory".to_string();
    let config = ctx.load_config(CONFIG)?;
    let mut has_git = false;
    for (flag, variable) in [
        (config.git.branch, "$git_branch$git_commit"),
        (config.git.tag, "${custom.git_tag}"),
        (config.git.state, "$git_state"),
        (config.git.status, "$git_status"),
    ] {
        if flag {
            format += variable;
            has_git = true;
        }
    }
    if has_git {
        format += " ";
    }
    format += "$cmake$rust$nodejs$python";
    format += "\n$jobs$character";

    let _ = writeln!(config_file, "# Starship config file generated by shaft");
    let _ = writeln!(config_file, "format = '''{format}'''");
    let _ = writeln!(config_file, "{}", include_str!("common_head.toml"));

    let mut config_file_modules = String::new();
    let _ = writeln!(config_file_modules, "{}", include_str!("common.toml"));
    config_file_modules += "\n";

    if config.git.branch {
        let _ = writeln!(
            config_file_modules,
            r#"[git_branch]
format = "[$symbol$branch]($style)"
truncation_length = 50
symbol = " "
style = "bright-purple"
only_attached = true

[git_commit]
format = '[ $hash]($style)'
style = "bright-green"
only_detached = true
tag_disabled = true
"#
        );
    }

    if config.git.tag {
        let _ = writeln!(
            config_file_modules,
            r#"[custom.git_tag]
when = true
require_repo = true
style = "bright-cyan"
shell = ["git","tag","--points-at","HEAD"]
format = "[( \uf412 $output)]($style)"
"#
        );
    }

    if config.git.state {
        let _ = writeln!(
            config_file_modules,
            r#"[git_state]
style = "bright-yellow"
"#
        );
    }

    if config.git.status {
        let _ = writeln!(
            config_file_modules,
            r#"[git_status]
format = "[($ahead_behind)]($style)"
behind = "[\uf433](bold red)"
ahead = "[\uf431](bold green)"
"#
        );
    }

    fn write_cmake(out: &mut String, enabled: bool) {
        let _ = writeln!(
            out,
            r#"[cmake]
format = "[$symbol($version )]($style)"
symbol = "\ue61d "
style = "bright-blue"
disabled = {}
"#,
            !enabled
        );
    }

    fn write_rust(out: &mut String, enabled: bool) {
        let _ = writeln!(
            out,
            r#"[rust]
format = "[$symbol($version )]($style)"
symbol = " "
style = "bright-red"
disabled = {}
"#,
            !enabled
        );
    }

    fn write_nodejs(out: &mut String, enabled: bool) {
        let _ = writeln!(
            out,
            r#"[nodejs]
format = "[$symbol($version )]($style)"
symbol = " "
style = "bright-green"
disabled = {}
"#,
            !enabled
        );
    }

    fn write_python(out: &mut String, enabled: bool) {
        let _ = writeln!(
            out,
            r#"[python]
format = '[$symbol$pyenv_prefix($version )(\($virtualenv\) )]($style)'
symbol = " "
detect_folders = [ "scripts/__pycache__" ]
style = "bright-yellow"
disabled = {}
"#,
            !enabled
        );
    }

    let mut config_file_modules_cmd = config_file_modules.clone();
    write_cmake(
        &mut config_file_modules,
        config.toolchain_value(|x| x.cmake),
    );
    write_rust(&mut config_file_modules, config.toolchain_value(|x| x.rust));
    write_nodejs(
        &mut config_file_modules,
        config.toolchain_value(|x| x.nodejs),
    );
    write_python(
        &mut config_file_modules,
        config.toolchain_value(|x| x.python),
    );

    write_cmake(
        &mut config_file_modules_cmd,
        config.toolchain_cmd_value(|x| x.cmake),
    );
    write_rust(
        &mut config_file_modules_cmd,
        config.toolchain_cmd_value(|x| x.rust),
    );
    write_nodejs(
        &mut config_file_modules_cmd,
        config.toolchain_cmd_value(|x| x.nodejs),
    );
    write_python(
        &mut config_file_modules_cmd,
        config.toolchain_cmd_value(|x| x.python),
    );

    let mut config_file_cmd = config_file.clone();
    config_file += include_str!("common.sh.toml");
    config_file += &config_file_modules;
    config_file_cmd += include_str!("common.cmd.toml");
    config_file_cmd += &config_file_modules_cmd;

    let config_file_location = ctx.install_dir().join("config.toml");
    cu::fs::write(&config_file_location, &config_file)?;
    let config_cmd_file_location = ctx.install_dir().join("config.cmd.toml");
    cu::fs::write(&config_cmd_file_location, &config_file_cmd)?;
    // set the default config as user env in the system,
    // since the CMD version will only be used if clink-cmd is used
    ctx.add_item(Item::user_env_var(
        "STARSHIP_CONFIG",
        config_file_location.into_utf8()?,
    ))?;
    ctx.add_item(Item::cmd(format!(
        "set STARSHIP_CONFIG={}",
        config_cmd_file_location.into_utf8()?
    )))?;
    ctx.add_item(Item::user_env_var(
        "STARSHIP_CACHE",
        ctx.install_dir().join("cache").into_utf8()?,
    ))?;
    if cfg!(windows) {
        let clink_profile = ctx.install_dir().join("clink-profile");
        let starship_cmd_lua = command_output!("starship", ["init", "cmd"]);
        cu::fs::write(clink_profile.join("starship.lua"), starship_cmd_lua)?;
        ctx.add_item(Item::user_env_var(
            "CLINK_PROFILE",
            clink_profile.as_utf8()?,
        ))?;
    }

    ctx.add_item(Item::bash("source <(starship init bash --print-full-init)"))?;
    ctx.add_item(Item::zsh("source <(starship init zsh --print-full-init)"))?;
    ctx.add_item(Item::pwsh(
        "iex (& starship init powershell --print-full-init | out-string)",
    ))?;

    // todo - clink-cmd
    CFG_VERSION.update()?;
    Ok(())
}

pub fn clean(ctx: &Context) -> cu::Result<()> {
    let _ = cu::fs::make_dir_absent_or_empty(ctx.install_dir().join("cache"));
    let Some(home) = std::env::home_dir() else {
        return Ok(());
    };
    let starship_old_home = home.join(".starship");
    let _ = cu::fs::rec_remove(starship_old_home);
    let dotcache = home.join(".cache");
    let dotcache_starship = dotcache.join("starship");
    let _ = cu::fs::rec_remove(dotcache_starship);
    let dotconfig = home.join(".config");
    let dotconfig_starship_toml = dotconfig.join("starship.toml");
    let _ = cu::fs::remove(dotconfig_starship_toml);

    Ok(())
}

config_file! {
    static CONFIG: Config = {
        template: include_str!("config.toml"),
        migration: [""],
    }
}

#[derive(Deserialize)]
#[serde(rename_all = "kebab-case")]
struct Config {
    pub git: ConfigGit,
    pub toolchains: ConfigToolchains,
    #[serde(default)]
    pub toolchains_cmd: ConfigToolchains,
}
impl Config {
    fn toolchain_value<F: Fn(&ConfigToolchains) -> Option<bool>>(&self, f: F) -> bool {
        f(&self.toolchains).unwrap_or_default()
    }
    fn toolchain_cmd_value<F: Fn(&ConfigToolchains) -> Option<bool>>(&self, f: F) -> bool {
        match f(&self.toolchains_cmd) {
            Some(x) => x,
            None => self.toolchain_value(f),
        }
    }
}

#[derive(Deserialize)]
#[serde(rename_all = "kebab-case")]
struct ConfigGit {
    #[serde(default)]
    branch: bool,
    #[serde(default)]
    tag: bool,
    #[serde(default)]
    state: bool,
    #[serde(default)]
    status: bool,
}

#[derive(Default, Deserialize)]
#[serde(rename_all = "kebab-case")]
struct ConfigToolchains {
    cmake: Option<bool>,
    rust: Option<bool>,
    nodejs: Option<bool>,
    python: Option<bool>,
}
