use std::collections::{BTreeMap, BTreeSet};
use std::path::PathBuf;

use cu::pre::*;
use itertools::Itertools as _;

use crate::parse::{ModuleData, ModuleFileStructure, ParsedModule};
use crate::util::{self, Platform};

pub struct RegistryBuilder {
    registry_path: PathBuf,
    packages: BTreeMap<String, ModuleFileStructure>,
}
impl RegistryBuilder {
    pub fn new(path: PathBuf) -> Self {
        Self {
            registry_path: path,
            packages: Default::default(),
        }
    }
    pub fn add(&mut self, structure: ModuleFileStructure) -> cu::Result<()> {
        use std::collections::btree_map::Entry;
        match self.packages.entry(structure.package_name.clone()) {
            Entry::Vacant(e) => {
                e.insert(structure);
            }
            Entry::Occupied(mut e) => {
                cu::check!(e.get_mut().extend(structure.files), "failed to merge files for package '{}'", e.key())?;
            }
        }
        Ok(())
    }
    pub fn build(self) -> cu::Result<String> {
        use std::fmt::Write as _;

        let mut out =
            "// This file is generated by the build script, do not edit manually.\n\n".to_string();
        writeln!(out, "#![allow(non_snake_case)]")?;
        writeln!(out, "#![allow(unused_braces)]")?;
        writeln!(out, "use enumset::{{EnumSetType, EnumSet, enum_set}};")?;
        writeln!(out, "use enum_map::Enum;")?;
        writeln!(out, "use super::_stub;")?;

        // if the package name contains invalid character,
        // there will be build error in the generated code.
        // the name is not validated here
        // (it should be rare since the registry is fully controlled by me)

        let kebab_pkgs = self.packages.keys().collect::<Vec<_>>();
        let (pascal_pkgs, snake_pkgs) = util::generate_casings_from_kebab(&kebab_pkgs);
        cu::check!(
            generate_id_enum(&mut out, "Pkg", &kebab_pkgs, &pascal_pkgs),
            "failed to generate PkgId enum"
        )?;

        let mut all_binaries = BTreeSet::default();
        let mut modules = Vec::with_capacity(kebab_pkgs.len());

        for (key, path) in &self.packages {
            let m = cu::check!(
                ParsedModule::parse(path),
                "failed to parse module '{key}'"
            )?;
            m.collect_binaries(&mut all_binaries);
            modules.push(m);
        }

        let kebab_bins = all_binaries.iter().collect::<Vec<_>>();
        let (pascal_bins, _) = util::generate_casings_from_kebab(&kebab_bins);
        cu::check!(
            generate_id_enum(&mut out, "Bin", &kebab_bins, &pascal_bins),
            "failed to generate BinId enum"
        )?;

        // metadata table
        writeln!(
            out,
            "static METADATA_ARRAY: &[crate::Package] = &["
        )?;
        build_metadata_array(&snake_pkgs, &kebab_pkgs, &modules, &mut out)?;
        writeln!(out, "];")?;

        writeln!(out, "impl PkgId {{")?;
        writeln!(
            out,
            "    /// Get package metadata\n    pub fn package(self) -> &'static crate::Package {{ &METADATA_ARRAY[Enum::into_usize(self)] }}"
        )?;
        writeln!(out, "}}")?;

        writeln!(out, "impl BinId {{")?;
        writeln!(
            out,
            "    /// Get packages that provide this binary\n    pub fn providers(self) -> EnumSet<PkgId> {{"
        )?;
        writeln!(out, "        match self {{")?;
        build_bin_providers(&pascal_bins, &kebab_bins, &pascal_pkgs, &modules, &mut out)?;
        writeln!(out, "        }}\n    }}\n}}")?;

        // declare package modules

        for (module, name) in std::iter::zip(self.packages.values(), &snake_pkgs) {
            for (platform, path) in &module.files {
                let path = path.normalize()?;
                let path = path.try_to_rel_from(&self.registry_path);
                // relative path ensures the output is consistent throughout
                // build environments
                cu::ensure!(path.is_relative());
                let path = path.as_utf8()?;
                writeln!(out, "{} #[path = \"{}\"] mod _pkg_{}{};", platform.cfg_attr(), path, name, platform.module_str())?;
            }
        }

        build_test(&mut out)?;

        Ok(out)
    }
}

fn build_metadata_array(
    snake_pkgs: &[String],
    kebab_pkgs: &[&String],
    modules: &[ParsedModule],
    out: &mut String
) -> cu::Result<()> {
    use std::fmt::Write as _;

    for (snake_name, (kebab_name, module)) in
    std::iter::zip(snake_pkgs, std::iter::zip(kebab_pkgs, modules))
    {
        for (platform, data) in &module.platform_data {
            build_metadata_for_module(snake_name, kebab_name, *platform, data, out)?;
        }
        if let Some(cfg) = Platform::cfg_attr_inverted(module.platform_data.keys().copied()) {
    writeln!(out, "    {cfg} {{ crate::Package::stub(\"{kebab_name}\") }},")?;
        }
    }
    Ok(())
}

fn build_metadata_for_module(
    snake_name: &str,
    kebab_name: &str,
    platform: Platform,
    data: &ModuleData,
    out: &mut String
) -> cu::Result<()> {
    use std::fmt::Write as _;

    writeln!(out, "    {} {{ crate::Package {{", platform.cfg_attr())?;
    writeln!(out, "        enabled: true,")?;
    writeln!(out, "        name: \"{kebab_name}\",")?;

    let binaries = data
        .kebab_binaries
        .iter()
        .map(|x| format!("BinId::{}", util::kebab_to_pascal(x)))
        .join(" | ");
    writeln!(out, "        binaries: enum_set!{{ {binaries} }},")?;
    writeln!(out, "        linux_flavors: {},", platform.linux_flavors())?;
    writeln!(out, "        short_desc: {},", json::stringify(data.short_desc())?)?;
    writeln!(out, "        long_desc: {},", json::stringify(&data.long_desc())?)?;
    let module_path = format!("_pkg_{}{}", snake_name, platform.module_str());

    // required functions
    writeln!(out, "        verify_fn: {module_path}::verify,")?;
    writeln!(out, "        install_fn: {module_path}::install,")?;
    writeln!(out, "        uninstall_fn: {module_path}::uninstall,")?;

    if data.has_binary_dependencies {
        writeln!(
            out,
            "        binary_dependencies_fn: {module_path}::binary_dependencies,"
        )?;
    } else {
        writeln!(
            out,
            "        binary_dependencies_fn: _stub::empty_bin_dependencies,"
        )?;
    }
    if data.has_config_dependencies {
        writeln!(
            out,
            "        config_dependencies_fn: {module_path}::config_dependencies,"
        )?;
    } else {
        writeln!(
            out,
            "        config_dependencies_fn: _stub::empty_pkg_dependencies,"
        )?;
    }
    if data.has_download {
        writeln!(
            out,
            "        download_fn: |ctx| Box::pin(async move {{ {module_path}::download(ctx.as_ref()).await }}),"
        )?;
    } else {
        writeln!(out, "        download_fn: _stub::ok_future,")?;
    }
    if data.has_build {
        writeln!(out, "        build_fn: {module_path}::build,")?;
    } else {
        writeln!(out, "        build_fn: _stub::ok,")?;
    }
    if data.has_configure {
        writeln!(out, "        configure_fn: {module_path}::configure,")?;
    } else {
        writeln!(out, "        configure_fn: _stub::ok,")?;
    }
    if data.has_clean {
        writeln!(out, "        clean_fn: {module_path}::clean,")?;
    } else {
        writeln!(out, "        clean_fn: _stub::ok,")?;
    }

    writeln!(out, "    }} }},")?;

    Ok(())
}


fn generate_id_enum(
    out: &mut String,
    prefix: &str,
    kebab_values: &[&String],
    pascal_values: &[String],
) -> cu::Result<()> {
    use std::fmt::Write as _;

    writeln!(out, "#[derive(Debug, EnumSetType, Enum)]")?;
    writeln!(out, "pub enum {prefix}Id {{")?;
    for name in pascal_values {
        writeln!(out, "    {name},")?;
    }
    writeln!(out, "}}")?;
    let upper_prefix = prefix.to_ascii_uppercase();
    writeln!(
        out,
        "static {upper_prefix}_NAMES: phf::Map<&'static str, {prefix}Id> = phf::phf_map! {{"
    )?;
    for (kebab, pascal) in std::iter::zip(kebab_values, pascal_values) {
        writeln!(out, "    \"{kebab}\" => {prefix}Id::{pascal},")?;
    }
    writeln!(out, "}};")?;
    writeln!(out, "impl {prefix}Id {{")?;
    writeln!(
        out,
        "    /// Convert kebab-case name to enum\n    pub fn from_str(name: &str) -> Option<Self> {{ {upper_prefix}_NAMES.get(name).copied() }}"
    )?;
    writeln!(
        out,
        "    /// Get kebab-case name\n    pub fn to_str(self) -> &'static str {{ match self {{"
    )?;
    for (kebab, pascal) in std::iter::zip(kebab_values, pascal_values) {
        writeln!(out, "            Self::{pascal} => \"{kebab}\",")?;
    }
    writeln!(out, "        }}\n    }}\n}}")?;

    Ok(())
}

fn build_bin_providers(
    pascal_bins: &[String],
    kebab_bins: &[&String],
    pascal_pkgs: &[String],
    modules: &[ParsedModule],
    out: &mut String,
) -> cu::Result<()> {
    use std::fmt::Write as _;

    for (pascal_bin, kebab_bin) in std::iter::zip(pascal_bins, kebab_bins) {
        let mut providers: BTreeMap<Platform, BTreeSet<String>> = BTreeMap::default();
        for (pascal_pkg, m) in std::iter::zip(pascal_pkgs, modules) {
            for (platform, data) in &m.platform_data {
                if !data.kebab_binaries.contains(kebab_bin.as_str()) {
                    continue;
                }
                for leaf_platform in platform.leaves() {
                    let set = providers.entry(*leaf_platform).or_default();
                    set.insert(format!("PkgId::{pascal_pkg}"));
                }
            }
        }
        Platform::combine_leaves(&mut providers);
        println!("cargo::warning={pascal_bin}:{providers:?}");
        writeln!( out, "            Self::{pascal_bin} => {{")?;
        let mut linux_flavors = vec![];
        for (platform, providers) in providers {
            if Platform::Linux.leaves().contains(&platform) {
                linux_flavors.push((platform, providers));
                continue;
            }
            writeln!(out,  "                {} {{ enum_set!{{ {} }} }}", platform.cfg_attr(), providers.iter().join(" | "))?;
        }
        if !linux_flavors.is_empty() {
            writeln!(out,  "                {} {{ match op::linux_flavor() {{", Platform::Linux.cfg_attr())?;
            for (platform, providers) in linux_flavors {
                writeln!(out,  "                    {} => enum_set! {{ {} }},", platform.linux_flavor(), providers.iter().join(" | "))?;
            }
            writeln!(out,  "                }} }}")?;
        }
        writeln!( out, "            }}")?;
    }

    Ok(())
}

fn build_test(out: &mut String) -> cu::Result<()> {
    let test = r"
#[cfg(test)]
mod gen_test {
    use super::*;
    #[test]
    fn test_registry() {
        for i in 0..PkgId::LENGTH {
            let pkg = PkgId::from_usize(i);
            assert_eq!(pkg.package().id(), pkg);
        }
    }
}
    ";

    out.push_str(test);
    Ok(())
}
