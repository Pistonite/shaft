use std::collections::{BTreeMap, BTreeSet};
use std::path::{Path, PathBuf};

use cu::pre::*;
use itertools::Itertools as _;

use crate::parse::{ModuleData, ModuleFileStructure, ParsedModule};
use crate::util::{self, Platform};

pub struct RegistryBuilder {
    registry_path: PathBuf,
    packages: BTreeMap<String, ModuleFileStructure>,
}
impl RegistryBuilder {
    pub fn new(path: PathBuf) -> Self {
        Self {
            registry_path: path,
            packages: Default::default(),
        }
    }
    pub fn add(&mut self, structure: ModuleFileStructure) -> cu::Result<()> {
        use std::collections::btree_map::Entry;
        match self.packages.entry(structure.package_name.clone()) {
            Entry::Vacant(e) => {
                e.insert(structure);
            }
            Entry::Occupied(mut e) => {
                cu::check!(
                    e.get_mut().extend(structure.files),
                    "failed to merge files for package '{}'",
                    e.key()
                )?;
            }
        }
        Ok(())
    }
    pub fn build(self) -> cu::Result<String> {
        use std::fmt::Write as _;

        let mut out =
            "// This file is generated by the build script, do not edit manually.\n\n".to_string();
        writeln!(out, "#![allow(non_snake_case)]")?;
        writeln!(out, "#![allow(non_camel_case_types)]")?;
        writeln!(out, "#![allow(unused_braces)]")?;
        writeln!(out, "#![allow(clippy::should_implement_trait)]")?;
        writeln!(out, "#![allow(clippy::non_minimal_cfg)]")?;
        writeln!(out, "use enumset::{{EnumSetType, EnumSet, enum_set}};")?;
        writeln!(out, "use enum_map::Enum;")?;
        writeln!(out, "use super::_stub;")?;

        // if the package name contains invalid character,
        // there will be build error in the generated code.
        // the name is not validated here
        // (it should be rare since the registry is fully controlled by me)

        let kebab_pkgs = self.packages.keys().collect::<Vec<_>>();
        let (pascal_pkgs, snake_pkgs) = util::generate_casings_from_kebab(&kebab_pkgs);
        cu::check!(
            generate_id_enum(&mut out, "Pkg", &kebab_pkgs, &pascal_pkgs),
            "failed to generate PkgId enum"
        )?;

        let mut all_binaries = BTreeSet::default();
        let mut modules = Vec::with_capacity(kebab_pkgs.len());

        for (key, path) in &self.packages {
            let m = cu::check!(ParsedModule::parse(path), "failed to parse module '{key}'")?;
            m.collect_binaries(&mut all_binaries);
            modules.push(m);
        }

        let kebab_bins = all_binaries.iter().collect::<Vec<_>>();
        let (pascal_bins, _) = util::generate_casings_from_kebab(&kebab_bins);
        cu::check!(
            generate_id_enum(&mut out, "Bin", &kebab_bins, &pascal_bins),
            "failed to generate BinId enum"
        )?;

        // metadata table
        writeln!(out, "static METADATA_ARRAY: &[crate::Package] = &[")?;
        build_metadata_array(&snake_pkgs, &kebab_pkgs, &modules, &mut out)?;
        writeln!(out, "];")?;

        writeln!(out, "impl PkgId {{")?;
        writeln!(
            out,
            "    /// Get package metadata\n    pub fn package(self) -> &'static crate::Package {{ &METADATA_ARRAY[Enum::into_usize(self)] }}"
        )?;
        writeln!(out, "}}")?;

        writeln!(out, "impl BinId {{")?;
        writeln!(
            out,
            "    /// Get packages that provide this binary\n    pub fn providers(self) -> EnumSet<PkgId> {{"
        )?;
        writeln!(out, "        match self {{")?;
        build_bin_providers(&pascal_bins, &kebab_bins, &pascal_pkgs, &modules, &mut out)?;
        writeln!(out, "        }}\n    }}\n}}")?;

        build_package_modules(
            &self.packages,
            &snake_pkgs,
            &modules,
            &self.registry_path,
            &mut out,
        )?;

        Ok(out)
    }
}

fn build_metadata_array(
    snake_pkgs: &[String],
    kebab_pkgs: &[&String],
    modules: &[ParsedModule],
    out: &mut String,
) -> cu::Result<()> {
    use std::fmt::Write as _;

    for (snake_name, (kebab_name, module)) in
        std::iter::zip(snake_pkgs, std::iter::zip(kebab_pkgs, modules))
    {
        let mut linux_flavors = vec![];
        let mut linux_flavors_data = vec![];
        for (platform, data) in &module.platform_data {
            if platform.is_linux_leaf() {
                linux_flavors.push(*platform);
                linux_flavors_data.push(data);
                continue;
            }
            build_metadata_for_module(
                snake_name,
                kebab_name,
                *platform,
                platform.linux_flavors(),
                false,
                data,
                out,
            )?;
        }
        if !linux_flavors.is_empty() {
            let linux_flavors = format!(
                "enum_set!{{ {} }}",
                linux_flavors.iter().map(|x| x.linux_flavor()).join(" | ")
            );
            let mut doc: Vec<String> = vec![];
            for data in linux_flavors_data {
                let next_doc = &data.doc;
                if !next_doc.is_empty() {
                    if !doc.is_empty() {
                        cu::bail!(
                            "only one linux flavor should specify description, in package '{kebab_name}'"
                        );
                    }
                    doc = next_doc.clone();
                }
            }
            let temp_data = ModuleData {
                doc,
                ..Default::default()
            };
            build_metadata_for_module(
                snake_name,
                kebab_name,
                Platform::Linux,
                &linux_flavors,
                true,
                &temp_data,
                out,
            )?;
        }
        let mut platforms: BTreeSet<Platform> = module.platform_data.keys().copied().collect();
        if !linux_flavors.is_empty() {
            for x in linux_flavors {
                platforms.remove(&x);
            }
            platforms.insert(Platform::Linux);
        }
        if let Some(cfg) = Platform::cfg_attr_inverted(platforms.into_iter()) {
            writeln!(
                out,
                "    {cfg} {{ crate::Package::stub(\"{kebab_name}\") }},"
            )?;
        }
    }
    Ok(())
}

fn build_metadata_for_module(
    snake_name: &str,
    kebab_name: &str,
    platform: Platform,
    linux_flavors: &str,
    is_linux_mux: bool,
    data: &ModuleData,
    out: &mut String,
) -> cu::Result<()> {
    use std::fmt::Write as _;

    let module_path = format!("_pkg_{}{}", snake_name, platform.module_str());

    writeln!(out, "    {} {{ crate::Package {{", platform.cfg_attr())?;
    writeln!(out, "        enabled: true,")?;
    writeln!(out, "        name: \"{kebab_name}\",")?;
    if is_linux_mux {
        writeln!(out, "        binaries_fn: {module_path}::binaries,")?;
    } else {
        let binaries = data
            .kebab_binaries
            .iter()
            .map(|x| format!("BinId::{}", util::kebab_to_pascal(x)))
            .join(" | ");
        writeln!(out, "        binaries_fn: || enum_set!{{ {binaries} }},")?;
    }

    writeln!(out, "        linux_flavors: {linux_flavors},")?;
    writeln!(
        out,
        "        short_desc: {},",
        json::stringify(data.short_desc())?
    )?;
    writeln!(
        out,
        "        long_desc: {},",
        json::stringify(&data.long_desc())?
    )?;

    // required functions
    writeln!(out, "        verify_fn: {module_path}::verify,")?;
    writeln!(out, "        install_fn: {module_path}::install,")?;
    writeln!(out, "        uninstall_fn: {module_path}::uninstall,")?;

    macro_rules! write_optional_function {
        ($has_ident:ident, $fn_name:literal, $stub_name:literal) => {
            if is_linux_mux || data.$has_ident {
                let fn_name = $fn_name;
                writeln!(out, "        {fn_name}_fn: {module_path}::{fn_name},")?;
            } else {
                writeln!(out, "        {}_fn: _stub::{},", $fn_name, $stub_name)?;
            }
        };
    }
    write_optional_function!(
        has_binary_dependencies,
        "binary_dependencies",
        "empty_bin_set"
    );
    write_optional_function!(
        has_config_dependencies,
        "config_dependencies",
        "empty_pkg_set"
    );
    write_optional_function!(has_download, "download", "ok");
    write_optional_function!(has_build, "build", "ok");
    write_optional_function!(has_configure, "configure", "ok");
    write_optional_function!(has_clean, "clean", "ok");
    write_optional_function!(has_config_location, "config_location", "ok_none");
    write_optional_function!(has_backup_restore, "backup", "ok");
    write_optional_function!(has_backup_restore, "restore", "ok");
    write_optional_function!(has_pre_uninstall, "pre_uninstall", "ok");

    writeln!(out, "    }} }},")?;

    Ok(())
}

fn generate_id_enum(
    out: &mut String,
    prefix: &str,
    kebab_values: &[&String],
    pascal_values: &[String],
) -> cu::Result<()> {
    use std::fmt::Write as _;

    writeln!(out, "#[derive(Debug, EnumSetType, Enum)]")?;
    writeln!(out, "pub enum {prefix}Id {{")?;
    for name in pascal_values {
        writeln!(out, "    {name},")?;
    }
    writeln!(out, "}}")?;
    let upper_prefix = prefix.to_ascii_uppercase();
    writeln!(
        out,
        "static {upper_prefix}_NAMES: phf::Map<&'static str, {prefix}Id> = phf::phf_map! {{"
    )?;
    for (kebab, pascal) in std::iter::zip(kebab_values, pascal_values) {
        writeln!(out, "    \"{kebab}\" => {prefix}Id::{pascal},")?;
    }
    writeln!(out, "}};")?;
    writeln!(out, "impl {prefix}Id {{")?;
    writeln!(
        out,
        "    /// Convert kebab-case name to enum\n    pub fn from_str(name: &str) -> Option<Self> {{ {upper_prefix}_NAMES.get(name).copied() }}"
    )?;
    writeln!(
        out,
        "    /// Get kebab-case name\n    pub fn to_str(self) -> &'static str {{ match self {{"
    )?;
    for (kebab, pascal) in std::iter::zip(kebab_values, pascal_values) {
        writeln!(out, "            Self::{pascal} => \"{kebab}\",")?;
    }
    writeln!(out, "        }}\n    }}\n}}")?;

    writeln!(
        out,
        r"
impl std::fmt::Display for {prefix}Id {{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {{
        self.to_str().fmt(f)
    }}
}}
    "
    )?;

    Ok(())
}

fn build_bin_providers(
    pascal_bins: &[String],
    kebab_bins: &[&String],
    pascal_pkgs: &[String],
    modules: &[ParsedModule],
    out: &mut String,
) -> cu::Result<()> {
    use std::fmt::Write as _;

    for (pascal_bin, kebab_bin) in std::iter::zip(pascal_bins, kebab_bins) {
        let mut providers: BTreeMap<Platform, BTreeSet<String>> = BTreeMap::default();
        for (pascal_pkg, m) in std::iter::zip(pascal_pkgs, modules) {
            for (platform, data) in &m.platform_data {
                if !data.kebab_binaries.contains(kebab_bin.as_str()) {
                    continue;
                }
                for leaf_platform in platform.leaves() {
                    let set = providers.entry(*leaf_platform).or_default();
                    set.insert(format!("PkgId::{pascal_pkg}"));
                }
            }
        }
        Platform::combine_leaves(&mut providers);
        writeln!(out, "            Self::{pascal_bin} => {{")?;
        let mut linux_flavors = vec![];
        for (platform, providers) in providers {
            if platform.is_linux_leaf() {
                linux_flavors.push((platform, providers));
                continue;
            }
            writeln!(
                out,
                "                {} {{ enum_set!{{ {} }} }}",
                platform.cfg_attr(),
                providers.iter().join(" | ")
            )?;
        }
        if !linux_flavors.is_empty() {
            writeln!(
                out,
                "                {} {{ match corelib::opfs::linux_flavor() {{",
                Platform::Linux.cfg_attr()
            )?;
            for (platform, providers) in linux_flavors {
                writeln!(
                    out,
                    "                    {} => enum_set! {{ {} }},",
                    platform.linux_flavor(),
                    providers.iter().join(" | ")
                )?;
            }
            writeln!(out, "                }} }}")?;
        }
        writeln!(out, "            }}")?;
    }

    Ok(())
}

fn build_package_modules(
    packages: &BTreeMap<String, ModuleFileStructure>,
    snake_pkgs: &[String],
    modules: &[ParsedModule],
    registry_path: &Path,
    out: &mut String,
) -> cu::Result<()> {
    use std::fmt::Write as _;
    let iter = packages.values().zip(modules.iter().zip(snake_pkgs));
    for (module, (parsed, name)) in iter {
        let mut linux_flavors = vec![];
        for (platform, path) in &module.files {
            if platform.is_linux_leaf() {
                linux_flavors.push(*platform);
            }
            let path = path.normalize()?;
            let path = path.try_to_rel_from(registry_path);
            // relative path ensures the output is consistent throughout
            // build environments
            cu::ensure!(path.is_relative(), "'{}'", path.display())?;
            let path = path.as_utf8()?;
            writeln!(
                out,
                "{} #[path = {}] mod _pkg_{}{};",
                platform.cfg_attr(),
                json::stringify(path)?,
                name,
                platform.module_str()
            )?;
        }
        // since linux flavors can't be decided at compile time,
        // generate a linux module to mux it at runtime
        if !linux_flavors.is_empty() {
            writeln!(
                out,
                "{} mod _pkg_{}{} {{",
                Platform::Linux.cfg_attr(),
                name,
                Platform::Linux.module_str()
            )?;
            {
                writeln!(
                    out,
                    "    pub fn binaries() -> enumset::EnumSet<super::BinId> {{ match corelib::opfs::linux_flavor() {{"
                )?;
                for platform in &linux_flavors {
                    let data = cu::check!(
                        parsed.platform_data.get(platform),
                        "failed to get module data for platform '{platform}', package '{name}'"
                    )?;
                    let binaries = data
                        .kebab_binaries
                        .iter()
                        .map(|x| format!("super::BinId::{}", util::kebab_to_pascal(x)))
                        .join(" | ");
                    writeln!(
                        out,
                        "        {} => enumset::enum_set!{{ {} }},",
                        platform.linux_flavor(),
                        binaries
                    )?;
                }
                writeln!(out, "        _ => Default::default(),")?;
                writeln!(out, "    }} }}")?;
            }
            {
                writeln!(
                    out,
                    "    pub fn config_location(_ctx: &crate::Context) -> cu::Result<Option<std::path::PathBuf>> {{ match corelib::opfs::linux_flavor() {{"
                )?;
                for platform in &linux_flavors {
                    let data = cu::check!(
                        parsed.platform_data.get(platform),
                        "failed to get module data for platform '{platform}', package '{name}'"
                    )?;
                    if data.has_config_location {
                        writeln!(
                            out,
                            "        {} => super::_pkg_{}{}::config_location(_ctx),",
                            platform.linux_flavor(),
                            name,
                            platform.module_str()
                        )?;
                    } else {
                        writeln!(out, "        {} => Ok(None),", platform.linux_flavor())?;
                    }
                }
                writeln!(out, "        _ => Ok(None),")?;
                writeln!(out, "    }} }}")?;
            }
            macro_rules! write_unreachable_match_arm {
                () => {
                    writeln!(out, "        _ => cu::bail!(\"unreachable\")")
                };
            }
            for fn_name in ["verify", "install", "uninstall"] {
                let retty = if fn_name == "verify" {
                    "crate::Verified"
                } else {
                    "()"
                };
                writeln!(
                    out,
                    "    pub fn {fn_name}(ctx: &crate::Context) -> cu::Result<{retty}> {{ match corelib::opfs::linux_flavor() {{"
                )?;
                for platform in &linux_flavors {
                    writeln!(
                        out,
                        "        {} => super::_pkg_{}{}::{}(ctx),",
                        platform.linux_flavor(),
                        name,
                        platform.module_str(),
                        fn_name
                    )?;
                }
                // the package functions will check the flavor before invoking vtable functions,
                // so the other platforms are not reachable
                write_unreachable_match_arm!()?;
                writeln!(out, "    }} }}")?;
            }
            macro_rules! write_optional_function {
                ($fn_name:literal, $has_ident:ident) => {
                    writeln!(out, "    pub fn {}(_ctx: &crate::Context) -> cu::Result<()> {{ match corelib::opfs::linux_flavor() {{", $fn_name)?;
                    for platform in &linux_flavors {
                        let platform_data = cu::check!(parsed.platform_data.get(&platform), "failed to get module data for platform '{platform}', package '{name}'")?;
                        if platform_data.$has_ident {
                            writeln!(out, "        {} => super::_pkg_{}{}::{}(_ctx),", platform.linux_flavor(), name, platform.module_str(), $fn_name)?;
                        } else {
                            writeln!(out, "        {} => Ok(()),", platform.linux_flavor())?;
                        }
                    }
                    write_unreachable_match_arm!()?;
                    writeln!(out, "    }} }}")?;
                }
            }
            write_optional_function!("download", has_download);
            write_optional_function!("build", has_build);
            write_optional_function!("configure", has_configure);
            write_optional_function!("clean", has_clean);
            write_optional_function!("backup", has_backup_restore);
            write_optional_function!("restore", has_backup_restore);
            write_optional_function!("pre_uninstall", has_pre_uninstall);
            macro_rules! write_dependency_function {
                ($fn_name:literal, $has_ident:ident, $retty:literal) => {
                    writeln!(
                        out,
                        "    pub fn {}() -> {} {{ match corelib::opfs::linux_flavor() {{",
                        $fn_name, $retty
                    )?;
                    for platform in &linux_flavors {
                        let platform_data = cu::check!(
                            parsed.platform_data.get(&platform),
                            "failed to get module data for platform '{platform}', package '{name}'"
                        )?;
                        if platform_data.$has_ident {
                            writeln!(
                                out,
                                "        {} => super::_pkg_{}{}::{}(),",
                                platform.linux_flavor(),
                                name,
                                platform.module_str(),
                                $fn_name
                            )?;
                        } else {
                            writeln!(
                                out,
                                "        {} => Default::default(),",
                                platform.linux_flavor()
                            )?;
                        }
                    }
                    writeln!(out, "        _ => Default::default(),")?;
                    writeln!(out, "    }} }}")?;
                };
            }
            write_dependency_function!(
                "binary_dependencies",
                has_binary_dependencies,
                "enumset::EnumSet<super::BinId>"
            );
            write_dependency_function!(
                "config_dependencies",
                has_config_dependencies,
                "enumset::EnumSet<super::PkgId>"
            );

            writeln!(out, "}}")?;
        }
    }
    Ok(())
}
