use std::fs::File;
use std::path::PathBuf;

use cu::pre::*;
use flate2::Compression;
use flate2::write::GzEncoder;
use ignore::WalkBuilder;
use sha2::{Digest, Sha256};
use tar::{Builder as TarBuilder, HeaderMode};

use crate::util;

pub fn build_tools() -> cu::Result<()> {
    let bytes = make_tools_targz()?;
    hash_tools_targz(&bytes)
}

/// Pack the tools directory into a .tar.gz at hmgr/tools.tar.gz
fn make_tools_targz() -> cu::Result<Vec<u8>> {
    let mut out_bytes = Vec::new();
    let mut tar_builder = {
        let gz_encoder = GzEncoder::new(&mut out_bytes, Compression::default());
        let mut builder = TarBuilder::new(gz_encoder);
        builder.mode(HeaderMode::Deterministic);
        builder.follow_symlinks(false);
        builder
    };

    let tools_path = util::tools_dir()?;
    let repo_root = util::repo_root_dir()?;
    let workspace_cargo_toml = repo_root.join("Cargo.toml");
    let workspace_cargo_toml =
        cu::toml::parse::<cu::toml::Table>(&cu::fs::read_string(&workspace_cargo_toml)?)?;

    // Create a Cargo.toml for tools that inherit dependencies versions
    // from shaft itself
    let tools_cargo_content = {
        let mut out = r#"
[workspace]
resolver = "2"
members = [
    "shaftim",
    "shaftim-build",
]
"#
        .to_string();
        let mut new_table = cu::toml::Table::new();
        if let Some(workspace) = workspace_cargo_toml.get("workspace") {
            if let Some(deps) = workspace.get("dependencies") {
                let mut ws = cu::toml::Table::new();
                ws.insert("dependencies".to_string(), deps.clone());
                new_table.insert("workspace".to_string(), cu::toml::Value::Table(ws));
            }
        }
        out.push_str(&cu::toml::stringify_pretty(&new_table)?);
        out
    };
    cu::fs::write(tools_path.join("Cargo.toml"), &tools_cargo_content)?;

    // cargo.toml is gitignored so we need to add it specifically
    {
        let bytes = tools_cargo_content.as_bytes();
        let mut header = tar::Header::new_gnu();
        header.set_path("Cargo.toml")?;
        header.set_size(bytes.len() as u64);
        header.set_mode(0o644);
        header.set_cksum();
        tar_builder.append(&header, bytes)?;
    }

    let mut builder = WalkBuilder::new(&tools_path);
    builder.filter_entry(|entry| {
        if entry.file_type().is_none_or(|x| !x.is_dir()) {
            return true;
        }
        cfg!(windows) || entry.file_name() != "__windows__"
    });
    builder.add_custom_ignore_filename(".corelibignore");

    for entry in builder.build() {
        let entry = entry?;
        let entry_path = entry.path();
        if !entry_path.is_file() {
            continue;
        }
        let rel_path = entry_path.try_to_rel_from(&tools_path);
        cu::ensure!(rel_path.is_relative(), "'{}'", rel_path.display())?;
        let mut file = cu::check!(
            File::open(entry_path),
            "failed to open '{}'",
            entry_path.display()
        )?;
        tar_builder.append_file(&rel_path, &mut file)?;
    }

    tar_builder.into_inner()?.finish()?;

    let output_path = tools_targz_path()?;
    cu::info!("saving tools to {}", output_path.display());
    util::write_bin_if_modified("tools.tar.gz", &output_path, &out_bytes)?;
    Ok(out_bytes)
}

fn hash_tools_targz(bytes: &[u8]) -> cu::Result<()> {
    let mut hasher = Sha256::new();
    hasher.update(bytes);
    let result = hasher.finalize();
    let mut out = String::with_capacity(64);
    let digits = b"0123456789abcdef";
    for b in result {
        let c1 = digits[(b / 16) as usize] as char;
        let c2 = digits[(b % 16) as usize] as char;
        out.push(c1);
        out.push(c2);
    }
    let gen_code = format!(
        r##"// generated by corelib build.rs
use crate::VersionCache;
pub static TOOLS_VERSION: VersionCache = VersionCache::new("corelib::TOOLS_VERSION", "{out}");
    "##
    );

    let output_path = tools_genrs_path()?;
    cu::info!("saving tools hash to {}", output_path.display());
    util::write_str_if_modified("tools.gen.rs", &output_path, &gen_code)?;
    Ok(())
}

fn tools_targz_path() -> cu::Result<PathBuf> {
    let mut path = util::corelib_dir()?;
    path.extend(["src", "hmgr", "tools.tar.gz"]);
    Ok(path)
}

fn tools_genrs_path() -> cu::Result<PathBuf> {
    let mut path = util::corelib_dir()?;
    path.extend(["src", "hmgr", "tools_targz.gen.rs"]);
    Ok(path)
}
